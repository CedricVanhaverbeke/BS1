<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>perlintern - perldoc.perl.org</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Language" content="en-gb" />
  <link href="css.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen" />
  <link rel="search" type="application/opensearchdescription+xml" title="Perldoc" href="opensearch.html">
</head>

<script language="JavaScript" type="text/javascript" src="label.js"></script>

<script language="JavaScript">
  pageDepth = 0;
  setPath();
</script>

<body onLoad="showToolbars();loadLabels()">

<div id="pageHeader">
  <div id="pageHeaderLogo">
    <img src="onion.gif">
  </div>
  <div id="pageHeaderText">
    <a href="http://perldoc.perl.org">perldoc.perl.org</a>
  </div>
</div>

<div id="pageBody">
  <div id="left">
    <div id="leftContent">
      <div id="leftClose">
        <a href="#" onClick="closeLeft()" title="Hide navigation" onmouseover="leftCloseIcon.src='close_purple.gif';" onmouseout="leftCloseIcon.src='close_blue.gif';"><img src="close_blue.gif" name="leftCloseIcon" id="leftCloseIcon" border=0></a>
      </div>
      <h1>Manual:</h1>
      <ul>
        <li><a href="index-overview.html">Overview</a></li>
        <li><a href="index-tutorials.html">Tutorials</a></li>
        <li><a href="index-faq.html">FAQs</a></li>
        <li><a href="index-history.html">History / Changes</a></li>
        <li><a href="index-licence.html">Licence</a></li>
      </ul>
      <h2>Reference:</h2>
      <ul>
        <li><a href="index-language.html">Language</a></li>
        <li><a href="index-functions.html">Functions</a></li>
        <li><a href="perlop.html">Operators</a></li>
        <li><a href="perlvar.html">Special variables</a></li>
        <li><a href="index-pragmas.html">Pragmas</a></li>
        <li><a href="index-modules-A.html">Core modules</a></li>
        <li><a href="index-utilities.html">Utilities</a></li>
        <li><a href="index-internals.html">Internals</a></li>
        <li><a href="index-platforms.html">Platform specific</a></li>
      </ul>
    </div>
  </div>

  <div id="center">  
    <div id="centerContent">
      <div id="contentHeader">
        <div id="contentHeaderLeft"><a href="#" onClick="showLeft()">Show navigation</a></div>
        <div id="contentHeaderCentre">-- Perl 5.10.0 documentation --</div>
        <div id="contentHeaderRight"><a href="#" onClick="showRight()">Show toolbar</a></div>
      </div>
      <div id="breadCrumbs"><a href="index.html">Home</a> &gt; <a href="index-internals.html">Internals and C language interface</a> &gt; perlintern</div>
      <script language="JavaScript">fromSearch();</script>
      <div id="contentBody"><div class="title_container"><div class="page_title">perlintern</div><ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION
 </a><li><a href="#CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</a><li><a href="#Functions-in-file-pad.h">Functions in file pad.h</a><li><a href="#GV-Functions">GV Functions</a><li><a href="#Hash-Manipulation-Functions">Hash Manipulation Functions</a><li><a href="#IO-Functions">IO Functions</a><li><a href="#Magical-Functions">Magical Functions</a><li><a href="#MRO-Functions">MRO Functions</a><li><a href="#Pad-Data-Structures">Pad Data Structures</a><li><a href="#Per-Interpreter-Variables">Per-Interpreter Variables</a><li><a href="#Stack-Manipulation-Macros">Stack Manipulation Macros</a><li><a href="#SV-Manipulation-Functions">SV Manipulation Functions</a><li><a href="#SV-Body-Allocation">SV-Body Allocation</a><li><a href="#Unicode-Support">Unicode Support</a><li><a href="#AUTHORS">AUTHORS</a><li><a href="#SEE-ALSO">SEE ALSO</a></ul><a name="NAME"></a><h1>NAME</h1>
<p>perlintern - autogenerated documentation of purely <b>internal</b>
		 Perl functions</p>
<a name="DESCRIPTION"></a><h1>DESCRIPTION
 </h1>
<p>This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API. In other words,
<b>they are not for use in extensions</b>!</p>
<a name="CV-reference-counts-and-CvOUTSIDE"></a><h1>CV reference counts and CvOUTSIDE</h1>
<ul>
<li><a name="CvWEAKOUTSIDE"></a><b>CvWEAKOUTSIDE
</b>
<p>Each CV has a pointer, <code class="inline"><span class="i">CvOUTSIDE</span><span class="s">(</span><span class="s">)</span></code>
, to its lexically enclosing
CV (if any). Because pointers to anonymous sub prototypes are
stored in <code class="inline"><span class="i">&amp;</span></code>
 pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by <code class="inline"><span class="w">CvOUTSIDE</span></code>
 in the <i>one specific instance</i> that the parent
has a <code class="inline"><span class="i">&amp;</span></code>
 pad slot pointing back to us. In this case, we set the
<code class="inline"><span class="w">CvWEAKOUTSIDE</span></code>
 flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.</p>
<p>There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg</p>
<pre class="verbatim">    BEGIN <span class="s">{</span> <span class="i">$a</span> = <a class="l_k" href="functions/sub.html">sub</a> <span class="s">{</span> <a class="l_k" href="functions/eval.html">eval</a> <span class="q">&#39;$x&#39;</span> <span class="s">}</span> <span class="s">}</span></pre>
<p>In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
<code class="inline"><span class="w">CvWEAKOUTSIDE</span></code>
 set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the <code class="inline"><a class="l_k" href="functions/eval.html">eval</a> <span class="q">&#39;$x&#39;</span></code>
 causes the chain of <code class="inline"><span class="w">CvOUTSIDE</span></code>
s to be followed,
and the freed BEGIN is accessed.</p>
<p>To avoid this, whenever a CV and its associated pad is freed, any
<code class="inline"><span class="i">&amp;</span></code>
 entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's <code class="inline"><span class="w">CvOUTSIDE</span></code>
 is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as <code class="inline"><span class="i">$a</span></code>
 above).</p>
<p>One other thing to consider is that a CV may be merely undefined
rather than freed, eg <code class="inline"><a class="l_k" href="functions/undef.html">undef</a> <span class="i">&amp;foo</span></code>
. In this case, its refcount may
not have reached zero, but we still delete its pad and its <code class="inline"><span class="w">CvROOT</span></code>
 etc.
Since various children may still have their <code class="inline"><span class="w">CvOUTSIDE</span></code>
 pointing at this
undefined CV, we keep its own <code class="inline"><span class="w">CvOUTSIDE</span></code>
 for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:</p>
<pre class="verbatim">    <a class="l_k" href="functions/my.html">my</a> <span class="i">$x</span> = <span class="n">123</span><span class="sc">;</span>
<a name="tmp"></a>    sub <span class="m">tmp</span> <span class="s">{</span> <a class="l_k" href="functions/sub.html">sub</a> <span class="s">{</span> <a class="l_k" href="functions/eval.html">eval</a> <span class="q">&#39;$x&#39;</span> <span class="s">}</span> <span class="s">}</span>
    <a class="l_k" href="functions/my.html">my</a> <span class="i">$a</span> = <span class="i">tmp</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <a class="l_k" href="functions/undef.html">undef</a> <span class="i">&amp;tmp</span><span class="sc">;</span>
    <a class="l_k" href="functions/print.html">print</a>  <span class="i">$a</span>-&gt;<span class="s">(</span><span class="s">)</span><span class="sc">;</span></pre>
<pre class="verbatim">	<span class="w">bool</span>	<span class="i">CvWEAKOUTSIDE</span><span class="s">(</span><span class="w">CV</span> *<span class="w">cv</span><span class="s">)</span></pre>
</li>
</ul>
<a name="Functions-in-file-pad.h"></a><h1>Functions in file pad.h</h1>
<ul>
<li><a name="CX_CURPAD_SAVE"></a><b>CX_CURPAD_SAVE
</b>
<p>Save the current pad in the given context block structure.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">CX_CURPAD_SAVE</span><span class="s">(</span><span class="w">struct</span> <span class="w">context</span><span class="s">)</span></pre>
</li>
<li><a name="CX_CURPAD_SV"></a><b>CX_CURPAD_SV
</b>
<p>Access the SV at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).</p>
<pre class="verbatim">	<span class="w">SV</span> *	<span class="i">CX_CURPAD_SV</span><span class="s">(</span><span class="w">struct</span> <span class="w">context</span><span class="cm">,</span> <span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_BASE_SV"></a><b>PAD_BASE_SV
</b>
<p>Get the value from slot <code class="inline"><span class="w">po</span></code>
 in the base (DEPTH=1) pad of a padlist</p>
<pre class="verbatim">	<span class="w">SV</span> *	<span class="i">PAD_BASE_SV</span><span class="s">(</span><span class="w">PADLIST</span> <span class="w">padlist</span><span class="cm">,</span> <span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_CLONE_VARS"></a><b>PAD_CLONE_VARS
</b>
<p>|CLONE_PARAMS* param
Clone the state variables associated with running and compiling pads.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_CLONE_VARS</span><span class="s">(</span><span class="w">PerlInterpreter</span> *<span class="w">proto_perl</span> \<span class="s">)</span></pre>
</li>
<li><a name="PAD_COMPNAME_FLAGS"></a><b>PAD_COMPNAME_FLAGS
</b>
<p>Return the flags for the current compiling pad name
at offset <code class="inline"><span class="w">po</span></code>
. Assumes a valid slot entry.</p>
<pre class="verbatim">	<span class="w">U32</span>	<span class="i">PAD_COMPNAME_FLAGS</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_COMPNAME_GEN"></a><b>PAD_COMPNAME_GEN
</b>
<p>The generation number of the name at offset <code class="inline"><span class="w">po</span></code>
 in the current
compiling pad (lvalue). Note that <code class="inline"><span class="w">SvUVX</span></code>
 is hijacked for this purpose.</p>
<pre class="verbatim">	<span class="w">STRLEN</span>	<span class="i">PAD_COMPNAME_GEN</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_COMPNAME_GEN_set"></a><b>PAD_COMPNAME_GEN_set
</b>
<p>Sets the generation number of the name at offset <code class="inline"><span class="w">po</span></code>
 in the current
ling pad (lvalue) to <code class="inline"><span class="w">gen</span></code>
.  Note that <code class="inline"><span class="w">SvUV_set</span></code>
 is hijacked for this purpose.</p>
<pre class="verbatim">	<span class="w">STRLEN</span>	<span class="i">PAD_COMPNAME_GEN_set</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">gen</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_COMPNAME_OURSTASH"></a><b>PAD_COMPNAME_OURSTASH
</b>
<p>Return the stash associated with an <code class="inline"><a class="l_k" href="functions/our.html">our</a></code> variable.
Assumes the slot entry is a valid <code class="inline"><a class="l_k" href="functions/our.html">our</a></code> lexical.</p>
<pre class="verbatim">	<span class="w">HV</span> *	<span class="i">PAD_COMPNAME_OURSTASH</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_COMPNAME_PV"></a><b>PAD_COMPNAME_PV
</b>
<p>Return the name of the current compiling pad name
at offset <code class="inline"><span class="w">po</span></code>
. Assumes a valid slot entry.</p>
<pre class="verbatim">	<span class="w">char</span> *	<span class="i">PAD_COMPNAME_PV</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_COMPNAME_TYPE"></a><b>PAD_COMPNAME_TYPE
</b>
<p>Return the type (stash) of the current compiling pad name at offset
<code class="inline"><span class="w">po</span></code>
. Must be a valid name. Returns null if not typed.</p>
<pre class="verbatim">	<span class="w">HV</span> *	<span class="i">PAD_COMPNAME_TYPE</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_DUP"></a><b>PAD_DUP
</b>
<p>Clone a padlist.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_DUP</span><span class="s">(</span><span class="w">PADLIST</span> <span class="w">dstpad</span><span class="cm">,</span> <span class="w">PADLIST</span> <span class="w">srcpad</span><span class="cm">,</span> <span class="w">CLONE_PARAMS</span>* <span class="w">param</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_RESTORE_LOCAL"></a><b>PAD_RESTORE_LOCAL
</b>
<p>Restore the old pad saved into the local variable opad by PAD_SAVE_LOCAL()</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_RESTORE_LOCAL</span><span class="s">(</span><span class="w">PAD</span> *<span class="w">opad</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SAVE_LOCAL"></a><b>PAD_SAVE_LOCAL
</b>
<p>Save the current pad to the local variable opad, then make the
current pad equal to npad</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_SAVE_LOCAL</span><span class="s">(</span><span class="w">PAD</span> *<span class="w">opad</span><span class="cm">,</span> <span class="w">PAD</span> *<span class="w">npad</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SAVE_SETNULLPAD"></a><b>PAD_SAVE_SETNULLPAD
</b>
<p>Save the current pad then set it to null.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_SAVE_SETNULLPAD</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SETSV"></a><b>PAD_SETSV
</b>
<p>Set the slot at offset <code class="inline"><span class="w">po</span></code>
 in the current pad to <code class="inline"><span class="w">sv</span></code>
</p>
<pre class="verbatim">	<span class="w">SV</span> *	<span class="i">PAD_SETSV</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="cm">,</span> <span class="w">SV</span>* <span class="w">sv</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SET_CUR"></a><b>PAD_SET_CUR
</b>
<p>Set the current pad to be pad <code class="inline"><span class="w">n</span></code>
 in the padlist, saving
the previous current pad. NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with</p>
<pre class="verbatim">    <span class="i">SAVECOMPPAD</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <span class="i">PAD_SET_CUR_NOSAVE</span><span class="s">(</span><span class="w">padlist</span><span class="cm">,</span><span class="w">n</span><span class="s">)</span><span class="sc">;</span></pre>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_SET_CUR</span><span class="s">(</span><span class="w">PADLIST</span> <span class="w">padlist</span><span class="cm">,</span> <span class="w">I32</span> <span class="w">n</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SET_CUR_NOSAVE"></a><b>PAD_SET_CUR_NOSAVE
</b>
<p>like PAD_SET_CUR, but without the save</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_SET_CUR_NOSAVE</span><span class="s">(</span><span class="w">PADLIST</span> <span class="w">padlist</span><span class="cm">,</span> <span class="w">I32</span> <span class="w">n</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SV"></a><b>PAD_SV
</b>
<p>Get the value at offset <code class="inline"><span class="w">po</span></code>
 in the current pad</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">PAD_SV</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="PAD_SVl"></a><b>PAD_SVl
</b>
<p>Lightweight and lvalue version of <code class="inline"><span class="w">PAD_SV</span></code>
.
Get or set the value at offset <code class="inline"><span class="w">po</span></code>
 in the current pad.
Unlike <code class="inline"><span class="w">PAD_SV</span></code>
, does not print diagnostics with -DX.
For internal use only.</p>
<pre class="verbatim">	<span class="w">SV</span> *	<span class="i">PAD_SVl</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="SAVECLEARSV"></a><b>SAVECLEARSV
</b>
<p>Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">SAVECLEARSV</span><span class="s">(</span><span class="w">SV</span> **<span class="w">svp</span><span class="s">)</span></pre>
</li>
<li><a name="SAVECOMPPAD"></a><b>SAVECOMPPAD
</b>
<p>save PL_comppad and PL_curpad</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">SAVECOMPPAD</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="SAVEPADSV"></a><b>SAVEPADSV
</b>
<p>Save a pad slot (used to restore after an iteration)</p>
<p>XXX DAPM it would make more sense to make the arg a PADOFFSET
	void	SAVEPADSV(PADOFFSET po)</p>
</li>
</ul>
<a name="GV-Functions"></a><h1>GV Functions</h1>
<ul>
<li><a name="is_gv_magical"></a><b>is_gv_magical
</b>
<p>Returns <code class="inline"><span class="w">TRUE</span></code>
 if given the name of a magical GV.</p>
<p>Currently only useful internally when determining if a GV should be
created even in rvalue contexts.</p>
<p><code class="inline"><span class="w">flags</span></code>
 is not used at present but available for future extension to
allow selecting particular classes of magical variable.</p>
<p>Currently assumes that <code class="inline"><span class="w">name</span></code>
 is NUL terminated (as well as len being valid).
This assumption is met by all callers within the perl core, which all pass
pointers returned by SvPV.</p>
<pre class="verbatim">	<span class="w">bool</span>	<span class="i">is_gv_magical</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span> *<span class="w">name</span><span class="cm">,</span> <span class="w">STRLEN</span> <span class="w">len</span><span class="cm">,</span> <span class="w">U32</span> <span class="w">flags</span><span class="s">)</span></pre>
</li>
<li><a name="is_gv_magical_sv"></a><b>is_gv_magical_sv
</b>
<p>Returns <code class="inline"><span class="w">TRUE</span></code>
 if given the name of a magical GV. Calls is_gv_magical.</p>
<pre class="verbatim">	<span class="w">bool</span>	<span class="i">is_gv_magical_sv</span><span class="s">(</span><span class="w">SV</span> *<span class="w">name</span><span class="cm">,</span> <span class="w">U32</span> <span class="w">flags</span><span class="s">)</span></pre>
</li>
</ul>
<a name="Hash-Manipulation-Functions"></a><h1>Hash Manipulation Functions</h1>
<ul>
<li><a name="refcounted_he_chain_2hv"></a><b>refcounted_he_chain_2hv
</b>
<p>Generates and returns a <code class="inline"><span class="w">HV</span> *</code>
 by walking up the tree starting at the passed
in <code class="inline"><span class="w">struct</span> <span class="w">refcounted_he</span> *</code>
.</p>
<pre class="verbatim">	<span class="w">HV</span> *	<span class="i">refcounted_he_chain_2hv</span><span class="s">(</span><span class="w">const</span> <span class="w">struct</span> <span class="w">refcounted_he</span> *<span class="w">c</span><span class="s">)</span></pre>
</li>
<li><a name="refcounted_he_free"></a><b>refcounted_he_free
</b>
<p>Decrements the reference count of the passed in <code class="inline"><span class="w">struct</span> <span class="w">refcounted_he</span> *</code>

by one. If the reference count reaches zero the structure's memory is freed,
and <code class="inline"><span class="w">refcounted_he_free</span></code>
 iterates onto the parent node.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">refcounted_he_free</span><span class="s">(</span><span class="w">struct</span> <span class="w">refcounted_he</span> *<span class="w">he</span><span class="s">)</span></pre>
</li>
<li><a name="refcounted_he_new"></a><b>refcounted_he_new
</b>
<p>Creates a new <code class="inline"><span class="w">struct</span> <span class="w">refcounted_he</span></code>
. As key is copied, and value is
stored in a compact form, all references remain the property of the caller.
The <code class="inline"><span class="w">struct</span> <span class="w">refcounted_he</span></code>
 is returned with a reference count of 1.</p>
<pre class="verbatim">	<span class="w">struct</span> <span class="w">refcounted_he</span> *	<span class="i">refcounted_he_new</span><span class="s">(</span><span class="w">struct</span> <span class="w">refcounted_he</span> *<span class="w">const</span> <span class="w">parent</span><span class="cm">,</span> <span class="w">SV</span> *<span class="w">const</span> <span class="w">key</span><span class="cm">,</span> <span class="w">SV</span> *<span class="w">const</span> <span class="w">value</span><span class="s">)</span></pre>
</li>
</ul>
<a name="IO-Functions"></a><h1>IO Functions</h1>
<ul>
<li><a name="start_glob"></a><b>start_glob
</b>
<p>Function called by <code class="inline"><span class="w">do_readline</span></code>
 to spawn a glob (or do the glob inside
perl on VMS). This code used to be inline, but now perl uses <code class="inline"><span class="w">File::Glob</span></code>

this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.</p>
<pre class="verbatim">	<span class="w">PerlIO</span>*	<span class="i">start_glob</span><span class="s">(</span><span class="w">SV</span>* <span class="w">pattern</span><span class="cm">,</span> <span class="w">IO</span> *<span class="w">io</span><span class="s">)</span></pre>
</li>
</ul>
<a name="Magical-Functions"></a><h1>Magical Functions</h1>
<ul>
<li><a name="magic_sethint"></a><b>magic_sethint
</b>
<p>Triggered by a delete from %^H, records the key to
<code class="inline"><span class="w">PL_compiling</span>.<span class="w">cop_hints_hash</span></code>
.</p>
<pre class="verbatim">	<a class="l_k" href="functions/int.html">int</a>	<span class="i">magic_sethint</span><span class="s">(</span><span class="w">SV</span>* <span class="w">sv</span><span class="cm">,</span> <span class="w">MAGIC</span>* <span class="w">mg</span><span class="s">)</span></pre>
</li>
<li><a name="mg_localize"></a><b>mg_localize
</b>
<p>Copy some of the magic from an existing SV to new localized version of
that SV. Container magic (eg %ENV, $1, tie) gets copied, value magic
doesn't (eg taint, pos).</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">mg_localize</span><span class="s">(</span><span class="w">SV</span>* <span class="w">sv</span><span class="cm">,</span> <span class="w">SV</span>* <span class="w">nsv</span><span class="s">)</span></pre>
</li>
</ul>
<a name="MRO-Functions"></a><h1>MRO Functions</h1>
<ul>
<li><a name="mro_get_linear_isa_c3"></a><b>mro_get_linear_isa_c3
</b>
<p>Returns the C3 linearization of @ISA
the given stash.  The return value is a read-only AV*.
<code class="inline"><span class="w">level</span></code>
 should be 0 (it is used internally in this
function's recursion).</p>
<p>You are responsible for <code class="inline"><span class="i">SvREFCNT_inc</span><span class="s">(</span><span class="s">)</span></code>
 on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).</p>
<pre class="verbatim">	<span class="w">AV</span>*	<span class="i">mro_get_linear_isa_c3</span><span class="s">(</span><span class="w">HV</span>* <span class="w">stash</span><span class="cm">,</span> <span class="w">I32</span> <span class="w">level</span><span class="s">)</span></pre>
</li>
<li><a name="mro_get_linear_isa_dfs"></a><b>mro_get_linear_isa_dfs
</b>
<p>Returns the Depth-First Search linearization of @ISA
the given stash.  The return value is a read-only AV*.
<code class="inline"><span class="w">level</span></code>
 should be 0 (it is used internally in this
function's recursion).</p>
<p>You are responsible for <code class="inline"><span class="i">SvREFCNT_inc</span><span class="s">(</span><span class="s">)</span></code>
 on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).</p>
<pre class="verbatim">	<span class="w">AV</span>*	<span class="i">mro_get_linear_isa_dfs</span><span class="s">(</span><span class="w">HV</span>* <span class="w">stash</span><span class="cm">,</span> <span class="w">I32</span> <span class="w">level</span><span class="s">)</span></pre>
</li>
<li><a name="mro_isa_changed_in"></a><b>mro_isa_changed_in
</b>
<p>Takes the necessary steps (cache invalidations, mostly)
when the @ISA of the given package has changed.  Invoked
by the <code class="inline"><span class="w">setisa</span></code>
 magic, should not need to invoke directly.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">mro_isa_changed_in</span><span class="s">(</span><span class="w">HV</span>* <span class="w">stash</span><span class="s">)</span></pre>
</li>
</ul>
<a name="Pad-Data-Structures"></a><h1>Pad Data Structures</h1>
<ul>
<li><a name="CvPADLIST"></a><b>CvPADLIST
</b>
<p>CV's can have CvPADLIST(cv) set to point to an AV.</p>
<p>For these purposes "forms" are a kind-of CV, eval""s are too (except they're
not callable at will and are always thrown away after the eval"" is done
executing). Require'd files are simply evals without any outer lexical
scope.</p>
<p>XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).</p>
<p>The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items
is managed "manual" (mostly in pad.c) rather than normal av.c rules.
The items in the AV are not SVs as for a normal AV, but other AVs:</p>
<p>0'th Entry of the CvPADLIST is an AV which represents the "names" or rather
the "static type information" for lexicals.</p>
<p>The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that
depth of recursion into the CV.
The 0'th slot of a frame AV is an AV which is @_.
other entries are storage for variables and op targets.</p>
<p>During compilation:
<code class="inline"><span class="w">PL_comppad_name</span></code>
 is set to the names AV.
<code class="inline"><span class="w">PL_comppad</span></code>
 is set to the frame AV for the frame CvDEPTH == 1.
<code class="inline"><span class="w">PL_curpad</span></code>
 is set to the body of the frame AV (i.e. AvARRAY(PL_comppad)).</p>
<p>During execution, <code class="inline"><span class="w">PL_comppad</span></code>
 and <code class="inline"><span class="w">PL_curpad</span></code>
 refer to the live
frame of the currently executing sub.</p>
<p>Iterating over the names AV iterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&amp;PL_sv_undef "names" (see pad_alloc()).</p>
<p>Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"" like
my/our variables can be.  Since they can't be looked up by "name"
but only by their index allocated at compile time (which is usually
in PL_op-&gt;op_targ), wasting a name SV for them doesn't make sense.</p>
<p>The SVs in the names AV have their PV being the name of the variable.
xlow+1..xhigh inclusive in the NV union is a range of cop_seq numbers for
which the name is valid.  For typed lexicals name SV is SVt_PVMG and SvSTASH
points at the type.  For <code class="inline"><a class="l_k" href="functions/our.html">our</a></code> lexicals, the type is also SVt_PVMG, with the
SvOURSTASH slot pointing at the stash of the associated global (so that
duplicate <code class="inline"><a class="l_k" href="functions/our.html">our</a></code> declarations in the same package can be detected).  SvUVX is
sometimes hijacked to store the generation number during compilation.</p>
<p>If SvFAKE is set on the name SV, then that slot in the frame AV is
a REFCNT'ed reference to a lexical from "outside". In this case,
the name SV does not use xlow and xhigh to store a cop_seq range, since it is
in scope throughout. Instead xhigh stores some flags containing info about
the real lexical (is it declared in an anon, and is it capable of being
instantiated multiple times?), and for fake ANONs, xlow contains the index
within the parent's pad where the lexical's value is stored, to make
cloning quicker.</p>
<p>If the 'name' is '&amp;' the corresponding entry in frame AV
is a CV representing a possible closure.
(SvFAKE and name of '&amp;' is not a meaningful combination currently but could
become so if <code class="inline"><a name="foo"></a><a class="l_k" href="functions/my.html">my</a> sub <span class="m">foo</span> <span class="s">{</span><span class="s">}</span></code>
 is implemented.)</p>
<p>Note that formats are treated as anon subs, and are cloned each time
write is called (if necessary).</p>
<p>The flag SVf_PADSTALE is cleared on lexicals each time the my() is executed,
and set on scope exit. This allows the 'Variable $x is not available' warning
to be generated in evals, such as</p>
<pre class="verbatim"><a name="f"></a>    <span class="s">{</span> <a class="l_k" href="functions/my.html">my</a> <span class="i">$x</span> = <span class="n">1</span><span class="sc">;</span> sub <span class="m">f</span> <span class="s">{</span> <a class="l_k" href="functions/eval.html">eval</a> <span class="q">&#39;$x&#39;</span><span class="s">}</span> <span class="s">}</span> <span class="i">f</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></pre>
<pre class="verbatim">	<span class="w">AV</span> *	<span class="i">CvPADLIST</span><span class="s">(</span><span class="w">CV</span> *<span class="w">cv</span><span class="s">)</span></pre>
</li>
<li><a name="cv_clone"></a><b>cv_clone
</b>
<p>Clone a CV: make a new CV which points to the same code etc, but which
has a newly-created pad built by copying the prototype pad and capturing
any outer lexicals.</p>
<pre class="verbatim">	<span class="w">CV</span>*	<span class="i">cv_clone</span><span class="s">(</span><span class="w">CV</span>* <span class="w">proto</span><span class="s">)</span></pre>
</li>
<li><a name="cv_dump"></a><b>cv_dump
</b>
<p>dump the contents of a CV</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">cv_dump</span><span class="s">(</span><span class="w">const</span> <span class="w">CV</span> *<span class="w">cv</span><span class="cm">,</span> <span class="w">const</span> <span class="w">char</span> *<span class="w">title</span><span class="s">)</span></pre>
</li>
<li><a name="do_dump_pad"></a><b>do_dump_pad
</b>
<p>Dump the contents of a padlist</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">do_dump_pad</span><span class="s">(</span><span class="w">I32</span> <span class="w">level</span><span class="cm">,</span> <span class="w">PerlIO</span> *<span class="w">file</span><span class="cm">,</span> <span class="w">PADLIST</span> *<span class="w">padlist</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">full</span><span class="s">)</span></pre>
</li>
<li><a name="intro_my"></a><b>intro_my
</b>
<p>"Introduce" my variables to visible status.</p>
<pre class="verbatim">	<span class="w">U32</span>	<span class="i">intro_my</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="pad_add_anon"></a><b>pad_add_anon
</b>
<p>Add an anon code entry to the current compiling pad</p>
<pre class="verbatim">	<span class="w">PADOFFSET</span>	<span class="i">pad_add_anon</span><span class="s">(</span><span class="w">SV</span>* <span class="w">sv</span><span class="cm">,</span> <span class="w">OPCODE</span> <span class="w">op_type</span><span class="s">)</span></pre>
</li>
<li><a name="pad_add_name"></a><b>pad_add_name
</b>
<p>Create a new name and associated PADMY SV in the current pad; return the
offset.
If <code class="inline"><span class="w">typestash</span></code>
 is valid, the name is for a typed lexical; set the
name's stash to that value.
If <code class="inline"><span class="w">ourstash</span></code>
 is valid, it's an our lexical, set the name's
SvOURSTASH to that value</p>
<p>If fake, it means we're cloning an existing entry</p>
<pre class="verbatim">	<span class="w">PADOFFSET</span>	<span class="i">pad_add_name</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span> *<span class="w">name</span><span class="cm">,</span> <span class="w">HV</span>* <span class="w">typestash</span><span class="cm">,</span> <span class="w">HV</span>* <span class="w">ourstash</span><span class="cm">,</span> <span class="w">bool</span> <span class="w">clone</span><span class="cm">,</span> <span class="w">bool</span> <span class="w">state</span><span class="s">)</span></pre>
</li>
<li><a name="pad_alloc"></a><b>pad_alloc
</b>
<p>Allocate a new my or tmp pad entry. For a my, simply push a null SV onto
the end of PL_comppad, but for a tmp, scan the pad from PL_padix upwards
for a slot which has no name and no active value.</p>
<pre class="verbatim">	<span class="w">PADOFFSET</span>	<span class="i">pad_alloc</span><span class="s">(</span><span class="w">I32</span> <span class="w">optype</span><span class="cm">,</span> <span class="w">U32</span> <span class="w">tmptype</span><span class="s">)</span></pre>
</li>
<li><a name="pad_block_start"></a><b>pad_block_start
</b>
<p>Update the pad compilation state variables on entry to a new block</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_block_start</span><span class="s">(</span><a class="l_k" href="functions/int.html">int</a> <span class="w">full</span><span class="s">)</span></pre>
</li>
<li><a name="pad_check_dup"></a><b>pad_check_dup
</b>
<p>Check for duplicate declarations: report any of:
     * a my in the current scope with the same name;
     * an our (anywhere in the pad) with the same name and the same stash
       as <code class="inline"><span class="w">ourstash</span></code>

<code class="inline"><span class="w">is_our</span></code>
 indicates that the name to check is an 'our' declaration</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_check_dup</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span>* <span class="w">name</span><span class="cm">,</span> <span class="w">bool</span> <span class="w">is_our</span><span class="cm">,</span> <span class="w">const</span> <span class="w">HV</span>* <span class="w">ourstash</span><span class="s">)</span></pre>
</li>
<li><a name="pad_findlex"></a><b>pad_findlex
</b>
<p>Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one.</p>
<p>Returns the offset in the bottom pad of the lex or the fake lex.
cv is the CV in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the IVX field of a fake namesv.</p>
<p>Note that pad_findlex() is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.</p>
<pre class="verbatim">	<span class="w">PADOFFSET</span>	<span class="i">pad_findlex</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span> *<span class="w">name</span><span class="cm">,</span> <span class="w">const</span> <span class="w">CV</span>* <span class="w">cv</span><span class="cm">,</span> <span class="w">U32</span> <span class="w">seq</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <a class="l_k" href="functions/warn.html">warn</a><span class="cm">,</span> <span class="w">SV</span>** <span class="w">out_capture</span><span class="cm">,</span> <span class="w">SV</span>** <span class="w">out_name_sv</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="i">*out_flags</span><span class="s">)</span></pre>
</li>
<li><a name="pad_findmy"></a><b>pad_findmy
</b>
<p>Given a lexical name, try to find its offset, first in the current pad,
or failing that, in the pads of any lexically enclosing subs (including
the complications introduced by eval). If the name is found in an outer pad,
then a fake entry is added to the current pad.
Returns the offset in the current pad, or NOT_IN_PAD on failure.</p>
<pre class="verbatim">	<span class="w">PADOFFSET</span>	<span class="i">pad_findmy</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span>* <span class="w">name</span><span class="s">)</span></pre>
</li>
<li><a name="pad_fixup_inner_anons"></a><b>pad_fixup_inner_anons
</b>
<p>For any anon CVs in the pad, change CvOUTSIDE of that CV from
old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be
moved to a pre-existing CV struct.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_fixup_inner_anons</span><span class="s">(</span><span class="w">PADLIST</span> *<span class="w">padlist</span><span class="cm">,</span> <span class="w">CV</span> *<span class="w">old_cv</span><span class="cm">,</span> <span class="w">CV</span> *<span class="w">new_cv</span><span class="s">)</span></pre>
</li>
<li><a name="pad_free"></a><b>pad_free
</b>
<p>Free the SV at offset po in the current pad.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_free</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="s">)</span></pre>
</li>
<li><a name="pad_leavemy"></a><b>pad_leavemy
</b>
<p>Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_leavemy</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="pad_new"></a><b>pad_new
</b>
<p>Create a new compiling padlist, saving and updating the various global
vars at the same time as creating the pad itself. The following flags
can be OR'ed together:</p>
<pre class="verbatim">    <span class="w">padnew_CLONE</span>	<span class="w">this</span> <span class="w">pad</span> <span class="w">is</span> for <span class="w">a</span> <span class="w">cloned</span> <span class="w">CV</span>
    <span class="w">padnew_SAVE</span>		<span class="w">save</span> <span class="w">old</span> <span class="w">globals</span>
    <span class="w">padnew_SAVESUB</span>	<span class="w">also</span> <span class="w">save</span> <span class="w">extra</span> <span class="w">stuff</span> for <span class="w">start</span> <span class="w">of</span> <a class="l_k" href="functions/sub.html">sub</a></pre>
<pre class="verbatim">	<span class="w">PADLIST</span>*	<span class="i">pad_new</span><span class="s">(</span><a class="l_k" href="functions/int.html">int</a> <span class="w">flags</span><span class="s">)</span></pre>
</li>
<li><a name="pad_push"></a><b>pad_push
</b>
<p>Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an @_ in slot zero.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_push</span><span class="s">(</span><span class="w">PADLIST</span> *<span class="w">padlist</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">depth</span><span class="s">)</span></pre>
</li>
<li><a name="pad_reset"></a><b>pad_reset
</b>
<p>Mark all the current temporaries for reuse</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_reset</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="pad_setsv"></a><b>pad_setsv
</b>
<p>Set the entry at offset po in the current pad to sv.
Use the macro PAD_SETSV() rather than calling this function directly.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_setsv</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="cm">,</span> <span class="w">SV</span>* <span class="w">sv</span><span class="s">)</span></pre>
</li>
<li><a name="pad_swipe"></a><b>pad_swipe
</b>
<p>Abandon the tmp in the current pad at offset po and replace with a
new one.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_swipe</span><span class="s">(</span><span class="w">PADOFFSET</span> <span class="w">po</span><span class="cm">,</span> <span class="w">bool</span> <span class="w">refadjust</span><span class="s">)</span></pre>
</li>
<li><a name="pad_tidy"></a><b>pad_tidy
</b>
<p>Tidy up a pad after we've finished compiling it:
    * remove most stuff from the pads of anonsub prototypes;
    * give it a @_;
    * mark tmps as such.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_tidy</span><span class="s">(</span><span class="w">padtidy_type</span> <span class="w">type</span><span class="s">)</span></pre>
</li>
<li><a name="pad_undef"></a><b>pad_undef
</b>
<p>Free the padlist associated with a CV.
If parts of it happen to be current, we null the relevant
PL_*pad* global vars so that we don't have any dangling references left.
We also repoint the CvOUTSIDE of any about-to-be-orphaned
inner subs to the outer of this cv.</p>
<p>(This function should really be called pad_free, but the name was already
taken)</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">pad_undef</span><span class="s">(</span><span class="w">CV</span>* <span class="w">cv</span><span class="s">)</span></pre>
</li>
</ul>
<a name="Per-Interpreter-Variables"></a><h1>Per-Interpreter Variables</h1>
<ul>
<li><a name="PL_DBsingle"></a><b>PL_DBsingle
</b>
<p>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
<code class="inline"><span class="w">PL_DBsub</span></code>
.</p>
<pre class="verbatim">	<span class="w">SV</span> *	<span class="w">PL_DBsingle</span></pre>
</li>
<li><a name="PL_DBsub"></a><b>PL_DBsub
</b>
<p>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
<code class="inline"><span class="w">PL_DBsingle</span></code>
.</p>
<pre class="verbatim">	<span class="w">GV</span> *	<span class="w">PL_DBsub</span></pre>
</li>
<li><a name="PL_DBtrace"></a><b>PL_DBtrace
</b>
<p>Trace variable used when Perl is run in debugging mode, with the <b>-d</b>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See <code class="inline"><span class="w">PL_DBsingle</span></code>
.</p>
<pre class="verbatim">	<span class="w">SV</span> *	<span class="w">PL_DBtrace</span></pre>
</li>
<li><a name="PL_dowarn"></a><b>PL_dowarn
</b>
<p>The C variable which corresponds to Perl's $^W warning variable.</p>
<pre class="verbatim">	<span class="w">bool</span>	<span class="w">PL_dowarn</span></pre>
</li>
<li><a name="PL_last_in_gv"></a><b>PL_last_in_gv
</b>
<p>The GV which was last used for a filehandle input operation. (<code class="inline"><span class="q">&lt;FH&gt;</span></code>
)</p>
<pre class="verbatim">	<span class="w">GV</span>*	<span class="w">PL_last_in_gv</span></pre>
</li>
<li><a name="PL_ofs_sv"></a><b>PL_ofs_sv
</b>
<p>The output field separator - <code class="inline"><span class="i">$,</span></code>
 in Perl space.</p>
<pre class="verbatim">	<span class="w">SV</span>*	<span class="w">PL_ofs_sv</span></pre>
</li>
<li><a name="PL_rs"></a><b>PL_rs
</b>
<p>The input record separator - <code class="inline"><span class="i">$/</span></code>
 in Perl space.</p>
<pre class="verbatim">	<span class="w">SV</span>*	<span class="w">PL_rs</span></pre>
</li>
</ul>
<a name="Stack-Manipulation-Macros"></a><h1>Stack Manipulation Macros</h1>
<ul>
<li><a name="djSP"></a><b>djSP
</b>
<p>Declare Just <code class="inline"><span class="w">SP</span></code>
. This is actually identical to <code class="inline"><span class="w">dSP</span></code>
, and declares
a local copy of perl's stack pointer, available via the <code class="inline"><span class="w">SP</span></code>
 macro.
See <code class="inline"><span class="w">SP</span></code>
.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)</p>
<pre class="verbatim">		<span class="w">djSP</span><span class="sc">;</span></pre>
</li>
<li><a name="LVRET"></a><b>LVRET
</b>
<p>True if this op will be the return value of an lvalue subroutine</p>
</li>
</ul>
<a name="SV-Manipulation-Functions"></a><h1>SV Manipulation Functions</h1>
<ul>
<li><a name="sv_add_arena"></a><b>sv_add_arena
</b>
<p>Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">sv_add_arena</span><span class="s">(</span><span class="w">char</span>* <span class="w">ptr</span><span class="cm">,</span> <span class="w">U32</span> <span class="w">size</span><span class="cm">,</span> <span class="w">U32</span> <span class="w">flags</span><span class="s">)</span></pre>
</li>
<li><a name="sv_clean_all"></a><b>sv_clean_all
</b>
<p>Decrement the refcnt of each remaining SV, possibly triggering a
cleanup. This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.</p>
<pre class="verbatim">	<span class="w">I32</span>	<span class="i">sv_clean_all</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="sv_clean_objs"></a><b>sv_clean_objs
</b>
<p>Attempt to destroy all objects not yet freed</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">sv_clean_objs</span><span class="s">(</span><span class="s">)</span></pre>
</li>
<li><a name="sv_free_arenas"></a><b>sv_free_arenas
</b>
<p>Deallocate the memory used by all arenas. Note that all the individual SV
heads and bodies within the arenas must already have been freed.</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">sv_free_arenas</span><span class="s">(</span><span class="s">)</span></pre>
</li>
</ul>
<a name="SV-Body-Allocation"></a><h1>SV-Body Allocation</h1>
<ul>
<li><a name="sv_2num"></a><b>sv_2num
</b>
<p>Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  You must use the <code class="inline"><span class="i">SvNUM</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code>
 macro to
access this function.</p>
<pre class="verbatim">	<span class="w">SV</span>*	<span class="i">sv_2num</span><span class="s">(</span><span class="w">SV</span>* <span class="w">sv</span><span class="s">)</span></pre>
</li>
</ul>
<a name="Unicode-Support"></a><h1>Unicode Support</h1>
<ul>
<li><a name="find_uninit_var"></a><b>find_uninit_var
</b>
<p>Find the name of the undefined variable (if any) that caused the operator o
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if it's value matches uninit_sv.
So roughly speaking, if a unary operator (such as OP_COS) generates a
warning, then following the direct child of the op may yield an
OP_PADSV or OP_GV that gives the name of the undefined variable. On the
other hand, with OP_ADD there are two branches to follow, so we only print
the variable name if we get an exact match.</p>
<p>The name is returned as a mortal SV.</p>
<p>Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.</p>
<pre class="verbatim">	<span class="w">SV</span>*	<span class="i">find_uninit_var</span><span class="s">(</span><span class="w">OP</span>* <span class="w">obase</span><span class="cm">,</span> <span class="w">SV</span>* <span class="w">uninit_sv</span><span class="cm">,</span> <span class="w">bool</span> <span class="w">top</span><span class="s">)</span></pre>
</li>
<li><a name="report_uninit"></a><b>report_uninit
</b>
<p>Print appropriate "Use of uninitialized variable" warning</p>
<pre class="verbatim">	<span class="w">void</span>	<span class="i">report_uninit</span><span class="s">(</span><span class="w">SV</span>* <span class="w">uninit_sv</span><span class="s">)</span></pre>
</li>
</ul>
<a name="AUTHORS"></a><h1>AUTHORS</h1>
<p>The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.</p>
<a name="SEE-ALSO"></a><h1>SEE ALSO</h1>
<p>perlguts(1), perlapi(1)</p>
</div>
      <div id="contentFooter"><a href="http://www.perl.org"><img src="perlpowered.png" border=0></a></div>
    </div>
  </div>

  <div id="right">
    <div id="rightContent">
      <div id="leftClose">
        <a href="#" onClick="closeRight()" title="Hide toolbar" onmouseover="rightCloseIcon.src='close_purple.gif';" onmouseout="rightCloseIcon.src='close_blue.gif';"><img src="close_blue.gif" name="rightCloseIcon" id="rightCloseIcon" border=0></a>
      </div>
      <h1>Search:</h1>
      <p>
        <form action="search.html" name="perldoc_search">
	  <input type="text" name="q" size="10" class="grey"><br>
	  <!--<select name="r"><option value="1" selected>Go to top result<option value="0">Show results list</select>-->
	</form>
      </p>
      <script language="JavaScript" type="text/javascript" src="/perl-version.js"></script>
      <h2>Labels:</h2>
      <p>
        <a href="#" onClick="addLabel('perlintern','perlintern.html')">Add this page</a>
      </p>
      <div class="labels" id="labels">
      </div>
    </div>
  </div>

</div>


</body>
</html>
